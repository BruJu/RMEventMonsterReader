package fr.bruju.rmeventreader.implementation.detectiondeformules.recomposeur.exploitation;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Supplier;

import fr.bruju.rmeventreader.implementation.detectiondeformules._personnages.Groupe;
import fr.bruju.rmeventreader.implementation.detectiondeformules._personnages.Individu;
import fr.bruju.rmeventreader.implementation.detectiondeformules._personnages.Personne;
import fr.bruju.rmeventreader.implementation.detectiondeformules.recomposeur.Parametres;
import fr.bruju.rmeventreader.utilitaire.Utilitaire;

import static fr.bruju.rmeventreader.ProjetS.PROJET;
import static fr.bruju.rmeventreader.utilitaire.Utilitaire.Maps;

public class BaseDeVariables {
	private int premiereVariableNonAllouee = 10001;

	private Map<Integer, Statistique> statistiquesConnues;

	private Map<String, Individu<StatsRecomposition>> personnagesConnus;
	private Map<Set<Individu<StatsRecomposition>>, Groupe<StatsRecomposition>> unificationsConnues;

	public BaseDeVariables() {
		statistiquesConnues = new HashMap<>();
		personnagesConnus = new HashMap<>();
		unificationsConnues = new HashMap<>();
	}
	
	public Set<Integer> getVariablesStatistiques() {
		return statistiquesConnues.keySet();
	}

	public void remplir(Parametres parametres) {
		List<String[]> param = parametres.getParametres("Statistiques");

		param.forEach(triplet -> {
			String nomPerso = triplet[0];
			String nomStat = triplet[1];

			boolean estPropriete = triplet[2].charAt(0) == 'S';

			if (estPropriete) {
				triplet[2] = triplet[2].substring(1);
			}
			
			int idVariable = Integer.decode(triplet[2]);
			
			if (estPropriete) {
				idVariable += 5000;
			}
			
			creerStatistique(nomPerso, nomStat, idVariable, estPropriete);
		});		
	}

	private void creerStatistique(String nomPerso, String nomStat, int idVariable, boolean estPropriete) {
		Individu<StatsRecomposition> perso = Maps.getX(personnagesConnus, nomPerso, creerNouvelIndividu(nomPerso));

		Statistique stat = new Statistique(perso, nomStat, idVariable, estPropriete);

		statistiquesConnues.put(stat.position, stat);
		perso.getVariablesAssociees().addStatistique(stat);
	}
	
	private Supplier<Individu<StatsRecomposition>> creerNouvelIndividu(String nomPerso) {
		return () -> new Individu<StatsRecomposition>(nomPerso, StatsRecomposition::new);
	}
	

	public Groupe<StatsRecomposition> unifierPersonnage(Personne<StatsRecomposition> p1, Personne<StatsRecomposition> p2) {
		Set<Individu<StatsRecomposition>> personnagesReels = new TreeSet<Individu<StatsRecomposition>>();

		personnagesReels.addAll(p1.getIndividus());
		personnagesReels.addAll(p2.getIndividus());

		return Utilitaire.Maps.getX(unificationsConnues, personnagesReels,
				() -> new Groupe<StatsRecomposition>(personnagesReels, p -> new StatsRecomposition(p, this)));
	}

	public Statistique creerStatistique(Groupe<StatsRecomposition> personnageUnifie, String nomStat, boolean estPropriete) {
		Statistique stat = new Statistique(personnageUnifie, nomStat, premiereVariableNonAllouee++, estPropriete);
		statistiquesConnues.put(stat.position, stat);
		return stat;
	}

	public Individu<StatsRecomposition> getPersonnage(String nomLanceur) {
		return personnagesConnus.get(nomLanceur);
	}

	public String getNomParIDHeros(int heros) {
		return PROJET.extraireHeros(heros);
	}

	public String getNomParIDObjet(int objet) {
		return Integer.toString(objet);
	}

	public String getNomVariable(int id) {
		if (statistiquesConnues.containsKey(id)) {
			Statistique a = statistiquesConnues.get(id);
			return a.possesseur.getNom() + "." + a.nom;
		} else {
			if (id <= 5000)
				return "{VAR " + id + ":" + PROJET.extraireVariable(id) + "}";
			else
				return "{SWI " + id + ":" + PROJET.extraireInterrupteur(id-5000) + "}";
		}
	}

	public Statistique getStatistiqueById(Integer variable) {
		return statistiquesConnues.get(variable);
	}
}
